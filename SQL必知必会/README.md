- 主键
	- 主键列的值不可以修改
	- 主键值不可重用→某行删除后主键不可以赋予新行
- SELECT
	- 未排序
	- 大小写
		- 语句不区分
		- 表明，列值，值可能有所不同，取决于DBMS配置
	- 检索不同的值：
		- `SELECT DISTINCT …`
		- SELECT默认为`ALL`
		- `DISTINCT`必须使用列名，不能用于计算或表达式
		- 指定多列时多列同时相同才不会重复检索
		- Access不支持
	- 限制结果数目：语法取决于数据库类型
		- SQL Server & Access：`SELECT TOP 5 XXX FROM XXX`
		- DB2：`SELECT XXX FROM XXX FETCH FIRST 5 ROWS ONLY`
		- Oracle：`SELECT XXX FROM XXX WHERE ROWNUM <= 5`
		- **MySQL**，MariaDB，PostgreSQL，**SQLite**：`SELECT XXX FROM XXX LIMIT 5`
	- `SELECT`→`FROM`→`WHERE`→`GROUP BY`→`HAVING`→`ORDER BY`
- 注释
	- `—`：后面为注释
	- `#`：行注释
	- `/*  …  */`：块注释
- 排序：`ORDER BY`
	- **必须是SELECT的最后一个字句**
	- 可以多列排序
	- 指定方向：
		- `DECS`:`….. ORDER BY xxx DECS`
		- 多列排序时需要在降序的每个列后面分别标明
		- 默认是`ASC`,一般不写
		- 大小写和排序的关系取决于数据库设置方式
			- 字典排序中A和a相同
- 过滤：
	- `WHERE`
		- 运算符：
			- 不等于：`<>`,`!=`【Access不支持`!=`】
			- 不小于：`!<`,`>=`
			- 为NULL：`IS NULL`
				- 不能用`= NULL`
			- 中间：`BETWEEN XXX AND XXX`
		- **`AND`的优先级高于`OR`**
			- 无论何时，都应该用圆括号来分组区分
		- `IN`：代替`OR`
			- `WHERE XXX IN (XX1,XX2)`
		- `NOT`:
			- `NOT XXX = XXX`
			- 大多数DBMS允许NOT否定任何条件
	- `LIKE`：
		- `WHERE XXX LIKE XXX`
		- 通配符：`%`
			- Access中使用`*`
			- 是否区分大小写取决于数据库配置
			- `LIKE ‘%’`无法匹配`NULL`
		- 要小心有些字段后面有空格填充，`F%Y`这种匹配要小心
		- 单个匹配:`_`
			- DB2不支持
			- Access中使用`?`
		- 字符集:`[]`
			- **只有微软的Access和SQL Server支持**
			- 脱字符`^`来否定
				- `Access`要使用`!`
				- `NOT`可以达到相同效果
		- **技巧**
			- 通配符耗时，如果其他操作符可以达到相同目的，应该使用其他操作符
			- 通配符置于开始处是**最慢**的
- 计算字段
	- 拼接：字符串用单引号
		- `+`：Access，SQL Server
		- `||`：DB2，Oracle，PostgreSQL，SQLite，Open Office Base
		- `Concat`：MySQL，MariaDB
	- 别名/导出列
		- 可选，最好使用
		- `AS`
		- 可以是单词，也可以是字符串(引号包含，但不推荐使用)
		- Access不支持别名排序
			- 可以用字段位置替换别名
- 函数：SQL函数不可移植
	- 子串
		- `MID()`：Access
		- `SUBSTR()`：DB2，Oracle，PostgreSQL，SQLite
		- `SUBSTRING()`：MySQL，SQL Server
	- 数据类型转换
		- 每种类型自带函数：Access，Oracle
		- `CAST()`：DB2，PostgreSQL
		- `CONVERT()`：MariaDB，MySQL，SQL Server
	- 当前日期
		- `NOW()`：Access
		- `CURRENT_DATE`：DB2，PostgreSQL
		- `CURDATE()`：MariaDB，MySQL
		- `SYSDATE`：Oracle
		- `GETDATE()`：SQL Server
		- `DATE()`：SQLite
	- 文本处理
		- `LEFT()`/`RIGHT`
		- `RTRIM()`/`TRIM()`/`LTRIM()`
		- `LENGTH()`/`DATALENGTH()`/`LEN()`
		- `LOWER()`/`UPPER()`
			- Access：`LCASE`/`UCASE`
		- `SOUNDEX`：文本转化为语音表示的字母模式
			- 可以匹配发音相似但拼写错误的名字，比如SOUNDEX(Michelle) = SOUNDEX(Michael)
			- Access，PostgreSQL不支持
	- 时间处理
		- 获取年份
			- SQL Server：`DATEPART(yy，xxx)`
			- Access:`DATEPART(‘yyyy’,xxx)`
			- PostgreSQL:`DATE_PART(‘year’,xxx)`
			- Oracle:`to_number(to_char(xxx,’YYYY’))`
			- MySQL,MariaDB:`YEAR()`
			- SQLite:`strftime(‘%Y’,xxx)`
		- 获取系统日期
			- SQL Server：`GETDATE()`
			- Access:`NOW()`
			- PostgreSQL:`CURRENT_DATE`
			- Oracle:`SYSDATE`
			- MySQL:`CURRENT_DATE()`
			- SQLite:`date(‘now’)`
			- DB2:`CURRENT_DATE`
	- 数学
		- `ABS()`
		- `COS()`/`SIN()`/`TAN()`
		- `EXP()`
		- `PI()`
		- `SQRT()`
	- 统计
		- `AVG()`
			- 会忽略NULL行
			- `SELECT AVG(DISTINCT xxx) AS XXXX …`
		- `COUNT()`
			- 会忽略NULL行
			- `COUNT(*)`对表中行的数目进行统计
			- `COUNT(column)`对表中特定值进行计数
			- `DISTINCT`不能用于`COUNT(*)`
		- `MAX()`/`MIN()`
			- 文本数据时，返回最后/最前的行
			- 会忽略NULL行
		- `SUM()`
			- 可以用于计算段
- 分组：GROUP BY
	- 结果不排序
	- 规定
		- 可以包含多列，所以可以实现分组嵌套
		- 如果分组嵌套，数组在最后指定的分组上进行汇总
		- 每一列都必须是检索列或有效表达式
		- **大多数SQL不允许分组可变长度数据类型**
		- 聚集函数外，SELECT每一列必须出现在GROUP BY中
			- 分组包含NULL，NULL将作为分组返回
		- **`WHERE` XXXX `GROUP BY` XXXXX`ORDER BY`**
	- 过滤分组：`HAVING`
		- WHERE没有分组的概念
		- 所有的`WHERE`都可以用`HAVING`来替换
			- 不指定`GROUP BY`，大部分DBMS同等对待
			- WHERE:过滤行，分组前过滤
			- HAVING：过滤分组，分组后过滤
- 子查询
	- 只能查询单列
	- 子查询并不总是检索最快的方式
- 联结
	- 关系表：相同的数据不应该出现多次
	- 必须有`WHERE`
		- 没有`WHERE`『叉联结』，结果将两个表的笛卡尔积
	- 内联结/等值联结
		- 两个表：`SELECT xx1,xx2 FROM tb1 INNER JOIN tb2 ON tb1.id = tb2.id`
		- 多个表：`SELECT xx1,xx2 FROM tb1,tb2,tb3 WHERE tb1.id = tb2.id AND tb2.name = tb3.name`
		- 不要联结不必要的表，性能下降
		- 一般DBMS会对可联结的表的数目有限制
- 给表起别名
	- 缩短SQL语句
	- **允许一条语句中使用多次相同的表**
	- 可用于`SELECT`,`WHERE`,`ORDER BY`
	- Oracle不需要写`AS`
	- 表别名不会返回客户端
- 高级联结
	- 自联结
		- WHERE中用表别名进行判断
		- 自联结与子查询对比：
			- 子查询：SELECT xx1,xx2 FROM tb1 WHERE xx2 = (SELECT XX2 FROM tb1 WHERE xx1 = ‘xxx’)
			- 自联结：SELECT t1.xx1,t1.xx2 FROM tb1 AS t1,tb1 AS t2 WHERE t1.xx2 = t2.xx2 AND t1.xx1 = ‘xxx’
			- 自联结处理速度快于子查询
	- 自然联结
		- 排除多次出现的列		
	- 外联结
		- SELECT … FROM … LEFT/RIGHT/FULL OUTER JOIN … ON …
		- 包含左/右表没关联的行
		- RIGHT OUTER JOIN：
			- 不支持SQLite
			- 解决：换表顺序
		- FULL OUTER JOIN：
			- 不支持：Access，MariaDB，MySQL，Open Office Base，SQLite
- 组合查询
	- 应用：
		- 一个查询中从不同表返回数据
		- 对一个表多次查询，按一次查询返回
	- SELECT之间加上UNION
	- 每次查询必须包含相同的列/表达式/聚集函数，次序不必相同
 	- UNION可以通过WHERE-AND实现
	- 自动去除重复行
		- 不去除需要`UNOIN ALL`
		- 无法用WHERE-AND实现
	- 只能使用一条`ORDER BY`,且必须位于最后一条`SELECT`
	- 特殊UNION
		- UNION：EXCEPT/MINUS
			- 第一个表中存在第二个表中不存在的行
		- INTERSECT
			- 第一个表中存在第二个表中都出现的行
		- 少用，相同结果都可以用联结得到
- 插入数据
	- OMSERT INTO tb VALUES(xxx,xxx):
		- 基于位置
		- 必须提供所有列
		- 最好不要用
	- OMSERT INTO tb(xx,xx) VALUES(xxx,xxx)
		- 可以插入部分行
		- 省略行
			- 允许定义NULL
			- 默认值
	- INTO可选，为了可移植性，最好提供
	- INSERT - SELECT:
		- INSERT INTO tb(xx,xx) SELECT xx,xx FROM tb2
		- 主键值重复，后续插入失败
		- 不要求列名匹配
	- 复制表：
		- SELECT * INTO tb_2 FROM tb_1
			- `DB2`不支持
		- 会自动创建新表
		- CREATE TABLE tb_2 AS SELECT * FROM tb_1
			- MariaDB,MySQL,Oracle,PostgreSQL,SQLite
- 更新数据
	- **不要省略WHERE！！！**
	- UPDATE tb SET xx = xxx **WHERE** …
	- 多个更新列之间逗号隔开
	- 可以使用子查询
	- 有些DBMS中UPDATE支持FROM，一个表更新另一个表
	- 删除列：UPDATE为NULL即可
- 删除数据	
	- **不要省略WHERE！！！**
	- DELETE FROM tb WHERE …
	- FROM可选，为了可移植性，最好提供
	- 删除所有行：`TRUNCATE TABLE`更快，不记录数据变动
	- **删除之前应该用SELECT测试！！**
- 表的操作
	- CREATE TABLE tb(xx CHAR(10) NOT NULL,
									xx VARCHAR(10) NULL)
	- NULL为默认
	- 语言限制
		- MySQL中VARCHAR需替换成text
		- DB2中如为NULL不需写
	- 指定默认值：`DEFAULT xxx`
		- 使用默认值比`NULL`好
	- 增加/删除列
		- ALTER TABLE tb ADD xxx CHAR(20)
		- ALTER TABLE tb DROP CLOUMN xxx
		- 使用前最好备份
	- 删除表：
		- DROP TABLE XXX
	- 重命名表：
		- RENAME:DB2，MariaDB，MySQL，Oracle，PostgreSQL
		- sp_rename：SQL Server
		- ALTER TABLE:SQLite
- 视图
	- Access不支持
	- 应用：
		- 重用语句
		- 简化操作
		- 使用表的一部分而非全部
		- 保护数据
		- 更改数据格式和表示
	- 视图不包含数据
	- 规则：
		- 唯一命名
		- 视图可以嵌套
		- 许多DBMS禁止视图中使用`ORDER BY`
		- 视图不可索引，关联触发器和默认值
		- CREATE VIEW view1 AS SELECT …
		- DROP VIEW view1
		- SELECT xxx FROM view1 …
- 使用存储过程
	- Access，SQLite不支持
	- 好处：简单，安全，高性能
	- 运行：
		- EXECUTE xxx(para1,para2…)
- 约束
	- 主键约束
		- 列满足以下条件即可定义
			- 任意两行主键值不同
			- 每行都有主键值（非NULL）
			- 主键值列从未被修改
			- 主键值不可重用
		- 定义方法：
			- 参数后面加：`PRIMARY KEY`
		- 增加方法：
			- ALTER TABLE xxx ADD CONSTRAINT PRIMARY KEY(xxx)
			- SQLite不支持ALTER TABLE定义主键/外键，必须建立时完成
	- 外键约束
		- 外键是表中的一列，也必须出现在另一张表中的主键
		- 有助于防止误删
		- 级联删除：
			- 删除一表中某行会删除另一表中相关数据
		- 定义方法：
			- 参数后面加：`REFERENCES tb2(xxx)`
		- 增加方法：
			- ALTER TABLE tb1 ADD CONSTRAINT FORIEGN KEY (xxx1) REFERENCES tb2(xxx2)
	- 唯一约束
		- 与主键约束区别：
			- 一张表可以包含多个唯一约束
			- 可以包含NULL
			- 可以更新或修改
			- 值可以重用
			- 不可定义外键
		- 定义方法：
			- UNIQUE
	- 检查约束
		- 常见用途
			- 检查最小值和最大值
			- 指定范围
				- CHECK (xxx > 0)
			- 只允许特定值
				- CHECK (gender LIKE ‘[MF]’)
- 索引
	- 改善检索性能，降低插入修改删除性能
	- 占用存储空间
	- 并非所有数据都适合索引
	- 索引可定义多个列
	- CREATE INDEX xxx_idx ON tb(xxx)
	- 索引名必须唯一
- 触发器
	- 与特定表上的INSERT,UPDATE,DELETE关联
	- 约束比触发器更快
	- 应用
		- 保证数据一致
		- 基于某个表的变动执行其他表的活动
		- 进行额外验证并根据需要回退数据
		- 计算计算列的值或更新时间戳
		- SQL Server:CREATE TRIGGER col 
								ON tb FOR INSERT,UPDATE 
								AS 
								UPDATE tb 
								SET col = Upper(col) 
								WHERE tb.xx = inserted.xx
		- Oracle,PostgreSQL:CREATE TRIGGER col 
											AFTER INSERT OR UPDATE 
											FOR EACH ROW 
											BEGIN
											UPDATE tb
											SET col = Upper(col)
											WHERE tb.xx = :OLD:xx
											END